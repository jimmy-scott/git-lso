#!/usr/bin/python

# Copyright (C) 2012 Jimmy Scott #jimmy#inet-solutions#be#. Belgium.
# All rights reserved.

import os
import sys
import re
import sha
import zlib
import getopt


class GitRepo(object):
	"""Holds git repository data"""
	
	_max_verbose = 3
	
	def __init__(self, repo, bare=False):
		"""Init variables"""
		
		self.verbose = 0
		self.show_compression = False
		self.error = None
		self.repo = repo
		self.bare = bare
		self.objects = []
		self.object_dirs = []
		
		if bare:
			self.git_dir = repo
		else:
			self.git_dir = os.path.join(repo, ".git")
		
		self.objects_root = os.path.join(self.git_dir, "objects")
	
	def _vprint(self, verbose_min, verbose_max, vrb_msg):
		"""Verbose aware print"""
		
		if self.verbose >= verbose_min and self.verbose <= verbose_max:
			sys.stdout.write(vrb_msg)
	
	def is_bare(self):
		"""Return self.bare"""
		
		return self.bare
	
	def set_verbose(self, verbose_level):
		"""Set verbose level"""
		
		if verbose_level < self._max_verbose:
			self.verbose = verbose_level
		else:
			self.verbose = self._max_verbose
	
	def set_show_compression(self, show_compression):
		"""Set to show compression"""
		
		self.show_compression = show_compression
	
	def get_error(self):
		"""Return self.error"""
		
		return self.error
	
	def reset_error(self):
		"""Reset the error status"""
		
		self.error = None
	
	def verify(self):
		"""Verify if self.objects_root exists and is a directory"""
		
		if not os.path.exists(self.objects_root):
			self.error = "no such directory: %s" % \
				self.objects_root
			return False
		
		if not os.path.isdir(self.objects_root):
			self.error = "not a directory: %s" % \
				self.objects_root
			return False
		
		return True
	
	def populate_objects(self):
		"""Gather a list of objects"""
		
		# Don't populate if already done
		if self.objects:
			return
		
		self.object_dirs = []
		dir_regex = re.compile("^[0-9a-f]{2}$")
		file_regex = re.compile("^[0-9a-f]{38}$")
		
		# Get list of object dirs
		for o_dir in os.listdir(self.objects_root):
			o_dir_path = os.path.join(self.objects_root, o_dir)
			if re.match(dir_regex, o_dir) and os.path.isdir(o_dir_path):
				# Looks like an object dir so far
				self.object_dirs.append((o_dir, o_dir_path))
		
		# Get list of object files
		for o_dir, o_dir_path in self.object_dirs:
			for o_file in os.listdir(o_dir_path):
				o_file_path = os.path.join(o_dir_path, o_file)
				if re.match(file_regex, o_file) and os.path.isfile(o_file_path):
					# Looks like an object file so far
					self.objects.append({
						'o_id': o_dir + o_file,
						'o_path': o_file_path,
						#'o_relpath': o_dir + "/" + o_file
					})
	
	def verify_objects(self):
		"""List gathered objects"""
		
		dfmt = "  %-15s %-s\n"
		vfmt = "  verify %-8s "
		cfmt = "  compression:    %-3s\n"
		_max_verbose = self._max_verbose
		
		if not self.objects:
			sys.stderr.write("No objects.\n")
			return
		
		for obj in self.objects:
			# Print object id and object path
			self._vprint(0, 0, "%s " % obj['o_id'])
			self._vprint(1, _max_verbose, "id: %s\n" % obj['o_id'])
			self._vprint(3, _max_verbose, "path: %s\n" % obj['o_path'])
			
			# Verify read
			self._vprint(1, _max_verbose, vfmt % "read:")
			try:
				obj_zdata = read_file_x(obj['o_path'], blob=True)
			except IOError as e:
				vmsg = "ERROR: IOError: [Errno %s] %s\n" % (e.errno, e.strerror)
				self._vprint(0, 0, "%s\n" % "ERROR")
				self._vprint(1, _max_verbose, vmsg)
				continue
			self._vprint(1, _max_verbose, "OK\n")
			
			# Show size of compressed object
			obj_zdata_sz = len(obj_zdata)
			self._vprint(3, _max_verbose, dfmt % ("zdata size:", obj_zdata_sz))
			
			# Verify zlib
			self._vprint(1, _max_verbose, vfmt % "zlib:")
			try:
				obj_xdata = zlib.decompress(obj_zdata)
			except zlib.error:
				vmsg = "ERROR: zlib decompress failed\n"
				self._vprint(0, 0, "%s\n" % "ERROR")
				self._vprint(1, _max_verbose, vmsg)
				continue
			self._vprint(1, _max_verbose, "OK\n")
			
			# Show size of uncompressed object
			obj_xdata_sz = len(obj_xdata)
			self._vprint(3, _max_verbose, dfmt % ("xdata size:", obj_xdata_sz))
			
			# Show compression ratio = 100 * COMP / UNCOMP
			if self.show_compression:
				ratio = 100 * obj_zdata_sz / obj_xdata_sz
				self._vprint(0, 0, "%3s%% " % ratio)
				self._vprint(1, _max_verbose, cfmt % (str(ratio) + "%"))
			
			# Verify format check 1
			self._vprint(1, 1, vfmt % "fmtx:")
			self._vprint(2, _max_verbose, vfmt % "fmt1:")
			try:
				obj_hdr, obj_data = obj_xdata.split("\x00", 1)
			except ValueError:
				vmsg = "ERROR: failed to extract header\n"
				self._vprint(0, 0, "%s\n" % "ERROR")
				self._vprint(1, _max_verbose, vmsg)
				continue
			self._vprint(2, _max_verbose, "OK\n")
			
			# Verify format check 2
			self._vprint(2, _max_verbose, vfmt % "fmt2:")
			try:
				obj_data_type, obj_data_len = obj_hdr.split(" ")
			except ValueError:
				vmsg = "ERROR: failed to split header\n"
				self._vprint(0, 0, "%s\n" % "ERROR")
				self._vprint(1, _max_verbose, vmsg)
				continue
			self._vprint(2, _max_verbose, "OK\n")
			
			# Verify format check 3
			self._vprint(2, _max_verbose, vfmt % "fmt3:")
			if not obj_data_type in ('blob', 'tree', 'commit', 'tag'):
				vmsg = "ERROR: invalid data type: %s\n" % obj_data_type
				self._vprint(0, 0, "%s\n" % "ERROR")
				self._vprint(1, _max_verbose, vmsg)
				continue
			self._vprint(2, _max_verbose, "OK\n")
			
			# Show object type
			self._vprint(3, _max_verbose, dfmt % ("obj type:", obj_data_type))
			
			# Verify format check 4 / final format check
			self._vprint(2, _max_verbose, vfmt % "fmt4:")
			if not obj_data_len.isdigit():
				vmsg = "ERROR: invalid data length: %s\n" % obj_data_len
				self._vprint(0, 0, "%s\n" % "ERROR")
				self._vprint(1, _max_verbose, vmsg)
				continue
			self._vprint(1, _max_verbose, "OK\n")
			
			# Show object size
			self._vprint(3, _max_verbose, dfmt % ("obj size:", obj_data_len))
			
			# Verify size
			self._vprint(1, _max_verbose, vfmt % "size:")
			if int(obj_data_len) != len(obj_data):
				vmsg = "ERROR: data length mismatch: %s vs %s\n" % \
					(int(obj_data_len), len(obj_data))
				self._vprint(0, 0, "%s\n" % "ERROR")
				self._vprint(1, _max_verbose, vmsg)
				continue
			self._vprint(1, _max_verbose, "OK\n")
			
			# Calculate checksum
			vrf_o_id = sha.sha(obj_data_type + " " + obj_data_len + 
				"\x00" + obj_data).hexdigest()
			
			# Verify checksum
			self._vprint(1, _max_verbose, vfmt % "sha1:")
			if vrf_o_id != obj['o_id']:
				vmsg = "ERROR: invalid checksum: %s\n" % vrf_o_id
				self._vprint(0, 0, "%s\n" % "ERROR")
				self._vprint(1, _max_verbose, vmsg)
				continue
			self._vprint(0, _max_verbose, "OK\n")


def read_file_x(filename, blob=False):
	"""Open a file, read it and return its content.
	
	Returns the content as a list or as a blob.
	Raises IOError on open or read error.
	"""
	
	fp = open(filename, "r")
	try:
		if blob:
			data = fp.read()
		else:
			data = fp.readlines()
	finally:
		fp.close()
	
	return data


def sysexit(msg, excode=70):
	sys.stderr.write("%s: %s\n" % (sys.argv[0], msg))
	sys.exit(excode)


def process_repo(repo):
	"""TODO"""
	
	# Verify it looks like a valid repo
	if not repo.verify():
		errmsg = "%s" % repo.get_error()
		if not repo.is_bare():
			errmsg += "\n\nMaybe you forgot --bare?"
		sysexit(errmsg, 65)
	
	# Populate objects
	repo.populate_objects()
	repo.verify_objects()


def usage(errmsg=None):
	if errmsg is not None:
		sys.stderr.write("%s: %s\n" % (sys.argv[0], errmsg))
	sys.stderr.write("usage: %s [-v] [-c] [--bare] [<git-repo-root>]\n\n"
	 	"   --bare             Operate on a bare repository\n" 
		"   -v, --verbose      Verbose, more -v flags increase the verbosity\n"
		"   -c, --compression  Show compression ratio as a percentage\n"
		% sys.argv[0])
	sys.exit(64)


def main():
	opts = "vch"
	long_opts = ['help', 'bare', 'verbose', 'compression']
	bare = False
	show_compression = False
	verbose = 0
	
	# Get options and arguments
	try:
		opts, args = getopt.getopt(sys.argv[1:], opts, long_opts)
	except getopt.GetoptError, error:
		usage(error)
	
	# Process options
	for opt, arg in opts:
		if opt == "--bare":
			bare = True
		elif opt in ('-v', '--verbose'):
			verbose += 1
		elif opt in ('-c', '--compression'):
			show_compression = True
		elif opt in ('-h', '--help'):
			usage()
		else:
			assert False, "unhandled option"
	
	# Process arguments
	if args:
		repo = args.pop(0)
	else:
		repo = os.curdir
	
	# No args should be left
	if args:
		usage("too many arguments: %s" % str.join(', ', args))
	
	# Create object and process repo
	repo = GitRepo(repo, bare)
	repo.set_verbose(verbose)
	repo.set_show_compression(show_compression)
	process_repo(repo)


if __name__ == "__main__":
	main()

