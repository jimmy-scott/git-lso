#!/usr/bin/python

# Copyright (C) 2012 Jimmy Scott #jimmy#inet-solutions#be#. Belgium.
# All rights reserved.

import os
import sys
import re
import sha
import zlib
import getopt


class GitRepo(object):
	"""Holds git repository data"""
	
	def __init__(self, repo, bare=False):
		"""Init variables"""
		
		self.error = None
		self.repo = repo
		self.bare = bare
		self.objects = []
		self.object_dirs = []
		
		if bare:
			self.git_dir = repo
		else:
			self.git_dir = os.path.join(repo, ".git")
		
		self.objects_root = os.path.join(self.git_dir, "objects")
	
	def is_bare(self):
		"""Return self.bare"""
		
		return self.bare
	
	def get_error(self):
		"""Return self.error"""
		
		return self.error
	
	def reset_error(self):
		"""Reset the error status"""
		
		self.error = None
	
	def verify(self):
		"""Verify if self.objects_root exists and is a directory"""
		
		if not os.path.exists(self.objects_root):
			self.error = "no such directory: %s" % \
				self.objects_root
			return False
		
		if not os.path.isdir(self.objects_root):
			self.error = "not a directory: %s" % \
				self.objects_root
			return False
		
		return True
	
	def populate_objects(self):
		"""Gather a list of objects"""
		
		# Don't populate if already done
		if self.objects:
			return
		
		self.object_dirs = []
		dir_regex = re.compile("^[0-9a-f]{2}$")
		file_regex = re.compile("^[0-9a-f]{38}$")
		
		# Get list of object dirs
		for o_dir in os.listdir(self.objects_root):
			o_dir_path = os.path.join(self.objects_root, o_dir)
			if re.match(dir_regex, o_dir) and os.path.isdir(o_dir_path):
				# Looks like an object dir so far
				self.object_dirs.append((o_dir, o_dir_path))
		
		# Get list of object files
		for o_dir, o_dir_path in self.object_dirs:
			for o_file in os.listdir(o_dir_path):
				o_file_path = os.path.join(o_dir_path, o_file)
				if re.match(file_regex, o_file) and os.path.isfile(o_file_path):
					# Looks like an object file so far
					self.objects.append({
						'o_id': o_dir + o_file,
						'o_path': o_file_path,
						#'o_relpath': o_dir + "/" + o_file
					})
	
	def verify_objects(self):
		"""List gathered objects"""
		
		if not self.objects:
			sys.stderr.write("No objects.\n")
			return
		
		for obj in self.objects:
			print "file: %s" % obj['o_path']
			print "\tid: %s" % obj['o_id']
			
			try:
				obj_zdata = read_file_x(obj['o_path'], blob=True)
			except IOError as e:
				print "\tERROR: IOError: [Errno %s] %s" % (e.errno, e.strerror)
				continue
			
			print "\tverify(read): OK"
			
			try:
				obj_xdata = zlib.decompress(obj_zdata)
			except zlib.error:
				print "\tERROR: zlib decompress failed\n\n"
				continue
			
			print "\tverify(zlib): OK"
			
			try:
				obj_hdr, obj_data = obj_xdata.split("\x00", 1)
			except ValueError:
				print "\tERROR: failed to extract header\n\n"
				continue
			
			print "\tverify(fmt1): OK"
			
			try:
				obj_data_type, obj_data_len = obj_hdr.split(" ")
			except ValueError:
				print "\tERROR: failed to split header\n\n"
				continue
			
			print "\tverify(fmt2): OK"
			
			if not obj_data_type in ('blob', 'tree', 'commit', 'tag'):
				print "\tERROR: invalid data type: %s\n\n" % obj_data_type
				continue
			
			print "\tverify(fmt3): OK"
			
			if not obj_data_len.isdigit():
				print "\tERROR: invalid data length: %s\n\n" % obj_data_len
				continue
			
			print "\tverify(fmt4): OK"
			
			if int(obj_data_len) != len(obj_data):
				print "\tERROR: data length mismatch: %s vs %s\n\n" % \
					(int(obj_data_len), len(obj_data))
				continue
			
			print "\tverify(size): OK"
			
			vrf_o_id = sha.sha(obj_data_type + " " + obj_data_len + 
				"\x00" + obj_data).hexdigest()
			
			if vrf_o_id != obj['o_id']:
				print "\tERROR: invalid checksum: %s\n\n" % vrf_o_id
				continue
			
			print "\tverify(sha1): OK"


def read_file_x(filename, blob=False):
	"""Open a file, read it and return its content.
	
	Returns the content as a list or as a blob.
	Raises IOError on open or read error.
	"""
	
	fp = open(filename, "r")
	try:
		if blob:
			data = fp.read()
		else:
			data = fp.readlines()
	finally:
		fp.close()
	
	return data


def sysexit(msg, excode=70):
	sys.stderr.write("%s: %s\n" % (sys.argv[0], msg))
	sys.exit(excode)


def process_repo(repo):
	"""TODO"""
	
	# Verify it looks like a valid repo
	if not repo.verify():
		errmsg = "%s" % repo.get_error()
		if not repo.is_bare():
			errmsg += "\n\nMaybe you forgot --bare?"
		sysexit(errmsg, 65)
	
	# Populate objects
	repo.populate_objects()
	repo.verify_objects()


def usage(errmsg=None):
	if errmsg is not None:
		sys.stderr.write("%s: %s\n" % (sys.argv[0], errmsg))
	sys.stderr.write("usage: %s [--bare] [<git-repo-root>]\n" %
		sys.argv[0])
	sys.exit(64)


def main():
	opts = "h"
	long_opts = ['help', 'bare']
	bare = False
	
	# Get options and arguments
	try:
		opts, args = getopt.getopt(sys.argv[1:], opts, long_opts)
	except getopt.GetoptError, error:
		usage(error)
	
	# Process options
	for opt, arg in opts:
		if opt == "--bare":
			bare = True
		elif opt in ('-h', '--help'):
			usage()
		else:
			assert False, "unhandled option"
	
	# Process arguments
	if args:
		repo = args.pop(0)
	else:
		repo = os.curdir
	
	# No args should be left
	if args:
		usage("too many arguments: %s" % str.join(', ', args))
	
	# Create object and process repo
	repo = GitRepo(repo, bare)
	process_repo(repo)


if __name__ == "__main__":
	main()

